% The Slide Definitions
\input{../templates/course_definitions}

% Author and Course information
\input{../templates/course_information}

% Presentation title
\title{Comprehensions}
\date{\today}


\begin{document}

\maketitle

\begin{frame}{Gliederung}
	\setbeamertemplate{section in toc}[sections numbered]
	\tableofcontents
\end{frame}


\section{Basics}
\begin{frame}{Basics}
  Comprehensions sind eine bequeme Art und Weise, um Funktoren (Datenstrukturen, die andere Datenstrukturen beinhalten) mit kleinen Expressions zu erstellen und zu füllen und sind in allen modernen Sprachen vorhanden.
\end{frame}



\section{List Comprehension}
\begin{frame}{List Comprehension}
  Grundlegender Syntax: \alert{\texttt{[ EXPRESSION for LAUFVARIABLE in ITERABLE (if FILTER) ]}}\\
  \begin{description}
    \item[EXPRESSION] Ist ein beliebiger Ausdruck (man stelle sich ein implizites \texttt{return} vor), etwa ein Wert, eine Variable, eine Gleichung, etc ... \\
    	\texttt{EXPRESSION} wird am Ende in der Liste abgelegt.
    \item[LAUFVARIABLE] Eine beliebige Variable, die in \textit{EXPRESSION} und \textit{FILTER} zur Verfügung steht
    \item[ITERABLE] Ist häufig etwas wie \texttt{range()} oder eine andere Liste.
    \item[FILTER] Eine optionale boolean expression, womit Einträge gefiltert werden (falls \texttt{False}). N\"utzlich, wenn z.B. nur gerade Zahlen \"ubernommen werden sollen, usw...
  \end{description}

\end{frame}

\begin{frame}{List Comprehension - Beispiel}
	\lstinputlisting{resources/06_comprehensions/lists.py}
\end{frame}



\section{Dict Comprehension}
\begin{frame}{Dict Comprehension}
  Grundlegender Syntax: \alert{\texttt{\{ KEY : VALUE for LAUFVARIABLE in ITERABLE (if FILTER) \}}}\\[.75cm]
  Fast der gleiche Syntax, nur dieses Mal mit 2 Expressions: \textit{KEY} und \textit{VALUE}. Ansonsten gelten die gleichen Regeln.
\end{frame}

\begin{frame}{Dict Comprehension - Beispiel}
	\lstinputlisting{resources/06_comprehensions/dicts.py}
\end{frame}



\section{Generators}
\begin{frame}{Generators}
	\begin{description}
		\item[Generator] Ein Objekt, \"uber das iteriert werden kann. Wenn ein Element daraus verwendet wurde, ist es nicht mehr in dem Generatorobjekt enthalten.\\[.5cm]
	\end{description}
	Grundlegender Syntax: \alert{\texttt{( EXPRESSION for LAUFVARIABLE in ITERABLE (if FILTER) )}}\\
	Da sich \alert{\texttt{list}} und \alert{\texttt{dict}} auch aus Iterables bauen lassen, gilt prinzipiell:\\[.25cm]

		\alert{\texttt{list(EXPRESSION for VARIABLE in ITERABLE) == [EXPRESSION for VARIABLE in ITERABLE]}}\\[.25cm]
		und\\[.25cm]
		\alert{\texttt{dict((KEY, VALUE) for VARIABLE in ITERABLE) == \{KEY:VALUE for VARIABLE in ITERABLE\}}}\\[.25cm]

	\textbf{Aber:} Generatoren sind lazy, sie erzeugen die Elemente erst wenn sie iteriert werden.
\end{frame}

\begin{frame}{Generators - Beispiel}
	\lstinputlisting{resources/06_comprehensions/generators.py}
\end{frame}

\section{Nesting}
\begin{frame}{Nesting}
	\alert{\texttt{for}} Schleifen in Comprehensions können verschachtelt werden.
	Dabei werden sie von Links nach Rechts ausgeführt, was man bei Variablen beachten muss.

	\textbf{Wichtig:} Starke Verschachtelung verringert die Lesbarkeit!
\end{frame}

\begin{frame}{Nesting - Beispiel}
	\lstinputlisting{resources/06_comprehensions/nesting.py}
\end{frame}

%\section{Misc}
%\begin{frame}{Misc}
%  Mit \texttt{tuple()} und der generator expression lassen sich theoretisch auch tuple comprehensions bauen, ist aber konzeptionell eher Unsinn.
%\end{frame}


% nothing to do from here on
\end{document}
